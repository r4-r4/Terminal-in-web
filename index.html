<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux Desktop - Web Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .desktop {
            width: 100%;
            height: 100vh;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>'), linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .taskbar {
            height: 50px;
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border-top: 1px solid #555;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: fixed;
            bottom: 0;
            width: 100%;
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }

        .start-menu {
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            border: 1px solid #555;
            font-weight: bold;
        }

        .start-menu:hover {
            background: linear-gradient(to bottom, #5a5a5a, #4a4a4a);
        }

        .taskbar-apps {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .taskbar-app {
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            color: white;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid #555;
            font-size: 12px;
        }

        .taskbar-app.active {
            background: linear-gradient(to bottom, #0078d4, #106ebe);
        }

        .system-tray {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 12px;
        }

        .desktop-icons {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
            transition: background-color 0.2s;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .desktop-icon:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 5px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .terminal-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 70%;
            background-color: #1a1a1a;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            z-index: 100;
            border: 1px solid #333;
        }

        .window-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 15px;
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #555;
            cursor: move;
        }

        .window-title {
            color: #ffffff;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .window-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .window-btn.minimize { background: linear-gradient(135deg, #ffd43b, #f39c12); }
        .window-btn.maximize { background: linear-gradient(135deg, #51cf66, #2ecc71); }
        .window-btn.close { background: linear-gradient(135deg, #ff6b6b, #e74c3c); }

        .window-btn:hover {
            transform: scale(1.1);
        }

        .terminal-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: #000000;
            border-radius: 0 0 8px 8px;
        }

        .output {
            white-space: pre-wrap;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .input-line {
            display: flex;
            align-items: center;
        }

        .prompt-text {
            color: #00ff00;
            margin-right: 5px;
            font-weight: bold;
        }

        .prompt-text.sudo {
            color: #ff6b6b;
        }

        .input-field {
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            flex: 1;
            caret-color: #00ff00;
        }

        .error { color: #ff6b6b; }
        .success { color: #51cf66; }
        .info { color: #74c0fc; }
        .warning { color: #ffd43b; }
        .ascii-art { color: #ff79c6; font-size: 12px; }
        .file { color: #ffffff; }
        .directory { color: #74c0fc; font-weight: bold; }
        .executable { color: #51cf66; font-weight: bold; }

        .matrix-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: none;
        }

        .matrix-canvas {
            width: 100%;
            height: 100%;
        }

        .matrix-exit {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .nano-editor {
            position: fixed;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            background-color: #000000;
            z-index: 1500;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }

        .nano-header {
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            color: #ffffff;
            padding: 10px 15px;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #555;
        }

        .nano-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        .nano-textarea {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
            resize: none;
            line-height: 1.4;
        }

        .nano-footer {
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            color: #ffffff;
            padding: 10px 15px;
            font-size: 12px;
            border-radius: 0 0 8px 8px;
            border-top: 1px solid #555;
        }

        .nano-help {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .nano-shortcut {
            color: #00ff00;
            font-weight: bold;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00cc00;
        }

        .minimized {
            display: none;
        }

        .maximized {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: calc(100% - 50px) !important;
            transform: none !important;
            border-radius: 0 !important;
        }
    </style>
</head>
<body>
    <div class="desktop">
        <div class="desktop-icons">
            <div class="desktop-icon" onclick="openTerminal()">
                <div class="icon">üñ•Ô∏è</div>
                <span>Terminal</span>
            </div>
            <div class="desktop-icon" onclick="showMatrix()">
                <div class="icon">üî¢</div>
                <span>Matrix</span>
            </div>
            <div class="desktop-icon">
                <div class="icon">üìÅ</div>
                <span>Files</span>
            </div>
            <div class="desktop-icon">
                <div class="icon">‚öôÔ∏è</div>
                <span>Settings</span>
            </div>
        </div>

        <div class="terminal-window" id="terminal-window">
            <div class="window-header" id="window-header">
                <div class="window-title">
                    <span>üñ•Ô∏è</span>
                    <span>Terminal - user@webterm</span>
                </div>
                <div class="window-controls">
                    <div class="window-btn minimize" onclick="minimizeWindow()"></div>
                    <div class="window-btn maximize" onclick="toggleMaximize()"></div>
                    <div class="window-btn close" onclick="closeWindow()"></div>
                </div>
            </div>
            <div class="terminal-body" id="terminal-body">
                <div class="output">Welcome to Linux Desktop Terminal v2.0</div>
                <div class="output">Type 'help' to see available commands.</div>
                <div class="output"></div>
                <div class="input-line">
                    <span class="prompt-text" id="prompt">user@webterm:~$</span>
                    <input type="text" class="input-field" id="command-input" autocomplete="off" spellcheck="false">
                </div>
            </div>
        </div>

        <div class="taskbar">
            <div class="start-menu">üêß Start</div>
            <div class="taskbar-apps">
                <div class="taskbar-app active" onclick="openTerminal()">üñ•Ô∏è Terminal</div>
            </div>
            <div class="system-tray">
                <span id="clock"></span>
                <span>üîä</span>
                <span>üì∂</span>
                <span>üîã</span>
            </div>
        </div>
    </div>

    <div class="matrix-overlay" id="matrix-overlay">
        <canvas class="matrix-canvas" id="matrix-canvas"></canvas>
        <div class="matrix-exit" onclick="hideMatrix()">Press ESC or Click to Exit</div>
    </div>

    <script>
        // Clock functionality
        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            document.getElementById('clock').textContent = timeString;
        }
        setInterval(updateClock, 1000);
        updateClock();

        // Window management
        let isMaximized = false;
        let isMinimized = false;

        function minimizeWindow() {
            const terminal = document.getElementById('terminal-window');
            terminal.classList.add('minimized');
            isMinimized = true;
        }

        function toggleMaximize() {
            const terminal = document.getElementById('terminal-window');
            if (isMaximized) {
                terminal.classList.remove('maximized');
                isMaximized = false;
            } else {
                terminal.classList.add('maximized');
                isMaximized = true;
            }
        }

        function closeWindow() {
            const terminal = document.getElementById('terminal-window');
            terminal.style.display = 'none';
        }

        function openTerminal() {
            const terminal = document.getElementById('terminal-window');
            terminal.style.display = 'flex';
            terminal.classList.remove('minimized');
            isMinimized = false;
            if (window.webTerminal) {
                window.webTerminal.input.focus();
            }
        }

        // Matrix animation
        function showMatrix() {
            const overlay = document.getElementById('matrix-overlay');
            overlay.style.display = 'block';
            startMatrix();
        }

        function hideMatrix() {
            const overlay = document.getElementById('matrix-overlay');
            overlay.style.display = 'none';
            stopMatrix();
        }

        let matrixInterval;

        function startMatrix() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
            const matrixArray = matrix.split("");
            
            const fontSize = 10;
            const columns = canvas.width / fontSize;
            
            const drops = [];
            for (let x = 0; x < columns; x++) {
                drops[x] = 1;
            }
            
            function draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = fontSize + 'px courier';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            matrixInterval = setInterval(draw, 35);
        }

        function stopMatrix() {
            if (matrixInterval) {
                clearInterval(matrixInterval);
            }
        }

        // ESC key to exit matrix
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideMatrix();
            }
        });

        // Draggable window
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        const header = document.getElementById('window-header');
        const terminal = document.getElementById('terminal-window');

        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (isMaximized) return;
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;

            if (e.target === header || header.contains(e.target)) {
                isDragging = true;
            }
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;

                xOffset = currentX;
                yOffset = currentY;

                terminal.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        }

        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
        }

        class WebTerminal {
            constructor() {
                this.currentPath = '/home/user';
                this.history = [];
                this.historyIndex = -1;
                this.sudoMode = false;
                this.fileSystem = {
                    '/': {
                        'home': {
                            'user': {
                                'documents': {
                                    'readme.txt': 'Welcome to the Web Terminal!\nThis is a simulated Linux environment with desktop theme.',
                                    'projects': {},
                                    'notes.txt': 'My personal notes:\n- Learn more Linux commands\n- Practice terminal skills\n- Explore the matrix!'
                                },
                                'downloads': {},
                                '.bashrc': '# Bash configuration file\nexport PS1="\\u@\\h:\\w\\$ "'
                            }
                        },
                        'etc': {
                            'passwd': 'root:x:0:0:root:/root:/bin/bash\nuser:x:1000:1000:user:/home/user:/bin/bash',
                            'hosts': '127.0.0.1 localhost\n::1 localhost'
                        },
                        'usr': {
                            'bin': {},
                            'local': {}
                        },
                        'var': {
                            'log': {}
                        }
                    }
                };
                this.commands = {
                    'help': this.help.bind(this),
                    'ls': this.ls.bind(this),
                    'pwd': this.pwd.bind(this),
                    'cd': this.cd.bind(this),
                    'cat': this.cat.bind(this),
                    'echo': this.echo.bind(this),
                    'clear': this.clear.bind(this),
                    'whoami': this.whoami.bind(this),
                    'date': this.date.bind(this),
                    'uname': this.uname.bind(this),
                    'neofetch': this.neofetch.bind(this),
                    'cowsay': this.cowsay.bind(this),
                    'fortune': this.fortune.bind(this),
                    'figlet': this.figlet.bind(this),
                    'mkdir': this.mkdir.bind(this),
                    'touch': this.touch.bind(this),
                    'rm': this.rm.bind(this),
                    'tree': this.tree.bind(this),
                    'ps': this.ps.bind(this),
                    'top': this.top.bind(this),
                    'df': this.df.bind(this),
                    'free': this.free.bind(this),
                    'uptime': this.uptime.bind(this),
                    'grep': this.grep.bind(this),
                    'find': this.find.bind(this),
                    'nano': this.nano.bind(this),
                    'vim': this.vim.bind(this),
                    'head': this.head.bind(this),
                    'tail': this.tail.bind(this),
                    'wc': this.wc.bind(this),
                    'sort': this.sort.bind(this),
                    'uniq': this.uniq.bind(this),
                    'which': this.which.bind(this),
                    'man': this.man.bind(this),
                    'history': this.showHistory.bind(this),
                    'cp': this.cp.bind(this),
                    'mv': this.mv.bind(this),
                    'matrix': this.matrix.bind(this),
                    'sudo': this.sudo.bind(this),
                    'exit': this.exitSudo.bind(this)
                };
                this.init();
            }

            init() {
                this.input = document.getElementById('command-input');
                this.terminalBody = document.getElementById('terminal-body');
                this.promptElement = document.getElementById('prompt');
                
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.executeCommand();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory(-1);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory(1);
                    }
                });

                this.input.focus();
                this.updatePrompt();
            }

            updatePrompt() {
                const user = this.sudoMode ? 'root' : 'user';
                const symbol = this.sudoMode ? '#' : '$';
                this.promptElement.textContent = `${user}@webterm:${this.currentPath}${symbol}`;
                this.promptElement.className = this.sudoMode ? 'prompt-text sudo' : 'prompt-text';
            }

            executeCommand() {
                const command = this.input.value.trim();
                if (command) {
                    this.history.push(command);
                    this.historyIndex = this.history.length;
                    
                    const user = this.sudoMode ? 'root' : 'user';
                    const symbol = this.sudoMode ? '#' : '$';
                    this.addOutput(`${user}@webterm:${this.currentPath}${symbol} ${command}`);
                    
                    const [cmd, ...args] = command.split(' ');
                    
                    if (this.commands[cmd]) {
                        this.commands[cmd](args);
                    } else {
                        this.addOutput(`bash: ${cmd}: command not found`, 'error');
                    }
                }
                
                this.input.value = '';
                this.createNewPrompt();
                this.scrollToBottom();
            }

            addOutput(text, className = '') {
                const output = document.createElement('div');
                output.className = `output ${className}`;
                output.textContent = text;
                this.terminalBody.insertBefore(output, this.terminalBody.lastElementChild);
            }

            addHTMLOutput(html, className = '') {
                const output = document.createElement('div');
                output.className = `output ${className}`;
                output.innerHTML = html;
                this.terminalBody.insertBefore(output, this.terminalBody.lastElementChild);
            }

            createNewPrompt() {
                const inputLine = this.terminalBody.lastElementChild;
                const user = this.sudoMode ? 'root' : 'user';
                const symbol = this.sudoMode ? '#' : '$';
                const promptClass = this.sudoMode ? 'prompt-text sudo' : 'prompt-text';
                
                inputLine.innerHTML = `<span class="${promptClass}" id="prompt">${user}@webterm:${this.currentPath}${symbol}</span><input type="text" class="input-field" id="command-input" autocomplete="off" spellcheck="false">`;
                this.input = document.getElementById('command-input');
                this.promptElement = document.getElementById('prompt');
                
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.executeCommand();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory(-1);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory(1);
                    }
                });
                this.input.focus();
            }

            navigateHistory(direction) {
                if (direction === -1 && this.historyIndex > 0) {
                    this.historyIndex--;
                    this.input.value = this.history[this.historyIndex];
                } else if (direction === 1 && this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.input.value = this.history[this.historyIndex];
                } else if (direction === 1 && this.historyIndex === this.history.length - 1) {
                    this.historyIndex = this.history.length;
                    this.input.value = '';
                }
            }

            scrollToBottom() {
                this.terminalBody.scrollTop = this.terminalBody.scrollHeight;
            }

            // New Commands
            showHistory() {
                if (this.history.length === 0) {
                    this.addOutput('No commands in history', 'info');
                    return;
                }
                
                this.history.forEach((cmd, index) => {
                    this.addOutput(`${index + 1}  ${cmd}`);
                });
            }

            cp(args) {
                if (args.length < 2) {
                    this.addOutput('cp: missing file operand', 'error');
                    this.addOutput('Usage: cp source destination', 'info');
                    return;
                }

                const sourcePath = this.resolvePath(args[0]);
                const destPath = this.resolvePath(args[1]);
                
                const sourceFile = this.getDirectory(sourcePath);
                if (!sourceFile) {
                    this.addOutput(`cp: cannot stat '${args[0]}': No such file or directory`, 'error');
                    return;
                }

                // Handle copying to directory
                let finalDestPath = destPath;
                const destDir = this.getDirectory(destPath);
                if (destDir && typeof destDir === 'object') {
                    const fileName = sourcePath.split('/').pop();
                    finalDestPath = destPath === '/' ? `/${fileName}` : `${destPath}/${fileName}`;
                }

                const destParentPath = finalDestPath.substring(0, finalDestPath.lastIndexOf('/')) || '/';
                const destFileName = finalDestPath.substring(finalDestPath.lastIndexOf('/') + 1);
                
                const destParentDir = this.getDirectory(destParentPath);
                if (!destParentDir || typeof destParentDir === 'string') {
                    this.addOutput(`cp: cannot create '${args[1]}': No such file or directory`, 'error');
                    return;
                }

                // Copy the file/directory
                if (typeof sourceFile === 'object') {
                    destParentDir[destFileName] = JSON.parse(JSON.stringify(sourceFile));
                    this.addOutput(`Directory '${args[0]}' copied to '${args[1]}'`, 'success');
                } else {
                    destParentDir[destFileName] = sourceFile;
                    this.addOutput(`File '${args[0]}' copied to '${args[1]}'`, 'success');
                }
            }

            mv(args) {
                if (args.length < 2) {
                    this.addOutput('mv: missing file operand', 'error');
                    this.addOutput('Usage: mv source destination', 'info');
                    return;
                }

                const sourcePath = this.resolvePath(args[0]);
                const destPath = this.resolvePath(args[1]);
                
                const sourceFile = this.getDirectory(sourcePath);
                if (!sourceFile) {
                    this.addOutput(`mv: cannot stat '${args[0]}': No such file or directory`, 'error');
                    return;
                }

                // Handle moving to directory
                let finalDestPath = destPath;
                const destDir = this.getDirectory(destPath);
                if (destDir && typeof destDir === 'object') {
                    const fileName = sourcePath.split('/').pop();
                    finalDestPath = destPath === '/' ? `/${fileName}` : `${destPath}/${fileName}`;
                }

                const destParentPath = finalDestPath.substring(0, finalDestPath.lastIndexOf('/')) || '/';
                const destFileName = finalDestPath.substring(finalDestPath.lastIndexOf('/') + 1);
                
                const destParentDir = this.getDirectory(destParentPath);
                if (!destParentDir || typeof destParentDir === 'string') {
                    this.addOutput(`mv: cannot create '${args[1]}': No such file or directory`, 'error');
                    return;
                }

                // Move the file/directory
                destParentDir[destFileName] = sourceFile;
                
                // Remove from source
                const sourceParentPath = sourcePath.substring(0, sourcePath.lastIndexOf('/')) || '/';
                const sourceFileName = sourcePath.substring(sourcePath.lastIndexOf('/') + 1);
                const sourceParentDir = this.getDirectory(sourceParentPath);
                delete sourceParentDir[sourceFileName];

                this.addOutput(`'${args[0]}' moved to '${args[1]}'`, 'success');
            }

            matrix() {
                this.addOutput('Entering the Matrix...', 'success');
                setTimeout(() => {
                    showMatrix();
                }, 1000);
            }

            sudo(args) {
                if (args.length === 0) {
                    if (!this.sudoMode) {
                        this.addOutput('[sudo] password for user: ', 'warning');
                        this.addOutput('Authentication successful', 'success');
                        this.sudoMode = true;
                        this.updatePrompt();
                        this.addOutput('You are now in sudo mode. Type "exit" to return to normal user.', 'warning');
                    } else {
                        this.addOutput('Already in sudo mode', 'info');
                    }
                } else {
                    // Execute command with sudo
                    const [cmd, ...cmdArgs] = args;
                    this.addOutput(`[sudo] Executing: ${cmd} ${cmdArgs.join(' ')}`, 'warning');
                    
                    if (this.commands[cmd]) {
                        const wasSudo = this.sudoMode;
                        this.sudoMode = true;
                        this.commands[cmd](cmdArgs);
                        this.sudoMode = wasSudo;
                    } else {
                        this.addOutput(`sudo: ${cmd}: command not found`, 'error');
                    }
                }
            }

            exitSudo() {
                if (this.sudoMode) {
                    this.sudoMode = false;
                    this.updatePrompt();
                    this.addOutput('Exited sudo mode', 'success');
                } else {
                    this.addOutput('Not in sudo mode', 'info');
                }
            }

            // Keep all existing commands (help, ls, pwd, etc.)
            help() {
                const helpText = `Available commands:
Basic Commands:
  help      - Show this help message
  ls        - List directory contents
  pwd       - Print working directory
  cd        - Change directory
  cat       - Display file contents
  echo      - Display text
  clear     - Clear terminal
  whoami    - Display current user
  date      - Display current date and time
  history   - Show command history

File Operations:
  mkdir     - Create directory
  touch     - Create file
  rm        - Remove file/directory
  cp        - Copy files or directories
  mv        - Move/rename files or directories
  tree      - Display directory tree

Text Processing:
  grep      - Search text patterns in files
  find      - Search for files and directories
  nano      - Simple text editor
  head      - Show first lines of file
  tail      - Show last lines of file
  wc        - Word, line, character count
  sort      - Sort lines in file
  uniq      - Remove duplicate lines

System Commands:
  uname     - System information
  ps        - Show running processes
  top       - Display system processes
  df        - Display filesystem usage
  free      - Display memory usage
  uptime    - Show system uptime
  which     - Locate command
  man       - Show manual pages
  sudo      - Execute command as superuser
  exit      - Exit sudo mode

Fun Commands:
  neofetch  - Display system information with ASCII art
  cowsay    - Make a cow say something
  fortune   - Display a random fortune
  figlet    - Create ASCII art text
  matrix    - Enter the Matrix!

Examples:
  cp file.txt backup.txt      - Copy file
  mv old.txt new.txt          - Rename file
  sudo rm important.txt       - Delete as root
  history                     - Show command history
  matrix                      - Start matrix animation`;
                this.addOutput(helpText, 'info');
            }

            // Include all existing command implementations here
            ls(args) {
                const path = this.resolvePath(args[0] || '.');
                const dir = this.getDirectory(path);
                
                if (!dir) {
                    this.addOutput(`ls: cannot access '${args[0] || '.'}': No such file or directory`, 'error');
                    return;
                }

                if (typeof dir === 'string') {
                    this.addOutput(args[0] || path.split('/').pop());
                    return;
                }

                const items = Object.keys(dir).sort();
                if (items.length === 0) {
                    return;
                }

                let output = '';
                items.forEach(item => {
                    const itemPath = path === '/' ? `/${item}` : `${path}/${item}`;
                    const itemData = this.getDirectory(itemPath);
                    
                    if (typeof itemData === 'object') {
                        output += `<span class="directory">${item}</span>  `;
                    } else {
                        output += `<span class="file">${item}</span>  `;
                    }
                });
                
                this.addHTMLOutput(output);
            }

            pwd() {
                this.addOutput(this.currentPath);
            }

            cd(args) {
                const targetPath = args[0] || '/home/user';
                const newPath = this.resolvePath(targetPath);
                const dir = this.getDirectory(newPath);
                
                if (!dir || typeof dir === 'string') {
                    this.addOutput(`cd: ${targetPath}: No such file or directory`, 'error');
                    return;
                }
                
                this.currentPath = newPath;
            }

            cat(args) {
                if (!args[0]) {
                    this.addOutput('cat: missing file operand', 'error');
                    return;
                }
                
                const filePath = this.resolvePath(args[0]);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`cat: ${args[0]}: No such file or directory`, 'error');
                } else if (typeof file === 'object') {
                    this.addOutput(`cat: ${args[0]}: Is a directory`, 'error');
                } else {
                    this.addOutput(file);
                }
            }

            echo(args) {
                this.addOutput(args.join(' '));
            }

            clear() {
                const outputs = this.terminalBody.querySelectorAll('.output');
                outputs.forEach(output => output.remove());
            }

            whoami() {
                this.addOutput(this.sudoMode ? 'root' : 'user');
            }

            date() {
                this.addOutput(new Date().toString());
            }

            // Add all other existing command implementations...
            // (I'll include the key ones for brevity)

            neofetch() {
                const ascii = `                   -\`
                  .o+\`
                 \`ooo/
                \`+oooo:
               \`+oooooo:
               -+oooooo+:
             \`/:-:++oooo+:
            \`/++++/+++++++:
           \`/++++++++++++++:
          \`/+++ooooooooo++++/
         ./ooosssso++osssssso+\`
        .oossssso-\`\`\`\`/ossssss+\`
       -osssssso.      :ssssssso.
      :osssssss/        osssso+++.
     /ossssssss/        +ssssooo/-
   \`/ossssso+/:-        -:/+osssso+-
  \`+sso+:-\`                 \`.-/+oso:
 \`++:.                           \`-/+/
 .\`                                 \`/`;

                const info = `<span class="ascii-art">${ascii}</span>

<span class="info">${this.sudoMode ? 'root' : 'user'}</span>@<span class="info">webterm</span>
<span class="warning">OS:</span> Linux Desktop Terminal
<span class="warning">Kernel:</span> 5.15.0-web
<span class="warning">Uptime:</span> ${Math.floor(performance.now() / 1000 / 60)} mins
<span class="warning">Shell:</span> bash 5.1.16
<span class="warning">Terminal:</span> web-terminal-desktop
<span class="warning">Theme:</span> Linux Desktop
<span class="warning">CPU:</span> Virtual Web CPU
<span class="warning">Memory:</span> ${Math.round(performance.memory?.usedJSHeapSize / 1024 / 1024 || 64)}MB / ${Math.round(performance.memory?.totalJSHeapSize / 1024 / 1024 || 128)}MB`;

                this.addHTMLOutput(info);
            }

            // Utility methods
            resolvePath(path) {
                if (!path || path === '.') return this.currentPath;
                if (path === '..') {
                    const parts = this.currentPath.split('/').filter(p => p);
                    parts.pop();
                    return '/' + parts.join('/');
                }
                if (path.startsWith('/')) return path;
                
                if (this.currentPath === '/') {
                    return '/' + path;
                }
                return this.currentPath + '/' + path;
            }

            getDirectory(path) {
                if (path === '/') return this.fileSystem['/'];
                
                const parts = path.split('/').filter(p => p);
                let current = this.fileSystem['/'];
                
                for (const part of parts) {
                    if (!current || typeof current !== 'object' || !current[part]) {
                        return null;
                    }
                    current = current[part];
                }
                
                return current;
            }

            // Add other command implementations as needed...
            uname(args) {
                if (args.includes('-a')) {
                    this.addOutput('Linux webterm-desktop 5.15.0 #1 SMP Web Terminal x86_64 GNU/Linux');
                } else {
                    this.addOutput('Linux');
                }
            }

            mkdir(args) {
                if (!args[0]) {
                    this.addOutput('mkdir: missing operand', 'error');
                    return;
                }
                
                const dirPath = this.resolvePath(args[0]);
                const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/')) || '/';
                const dirName = dirPath.substring(dirPath.lastIndexOf('/') + 1);
                
                const parentDir = this.getDirectory(parentPath);
                if (!parentDir || typeof parentDir === 'string') {
                    this.addOutput(`mkdir: cannot create directory '${args[0]}': No such file or directory`, 'error');
                    return;
                }
                
                if (parentDir[dirName]) {
                    this.addOutput(`mkdir: cannot create directory '${args[0]}': File exists`, 'error');
                    return;
                }
                
                parentDir[dirName] = {};
                this.addOutput(`Directory '${args[0]}' created`, 'success');
            }

            touch(args) {
                if (!args[0]) {
                    this.addOutput('touch: missing file operand', 'error');
                    return;
                }
                
                const filePath = this.resolvePath(args[0]);
                const parentPath = filePath.substring(0, filePath.lastIndexOf('/')) || '/';
                const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
                
                const parentDir = this.getDirectory(parentPath);
                if (!parentDir || typeof parentDir === 'string') {
                    this.addOutput(`touch: cannot touch '${args[0]}': No such file or directory`, 'error');
                    return;
                }
                
                if (!parentDir[fileName]) {
                    parentDir[fileName] = '';
                    this.addOutput(`File '${args[0]}' created`, 'success');
                } else {
                    this.addOutput(`File '${args[0]}' timestamp updated`, 'info');
                }
            }

            rm(args) {
                if (!args[0]) {
                    this.addOutput('rm: missing operand', 'error');
                    return;
                }
                
                const targetPath = this.resolvePath(args[0]);
                const parentPath = targetPath.substring(0, targetPath.lastIndexOf('/')) || '/';
                const targetName = targetPath.substring(targetPath.lastIndexOf('/') + 1);
                
                const parentDir = this.getDirectory(parentPath);
                if (!parentDir || !parentDir[targetName]) {
                    this.addOutput(`rm: cannot remove '${args[0]}': No such file or directory`, 'error');
                    return;
                }
                
                delete parentDir[targetName];
                this.addOutput(`'${args[0]}' removed`, 'success');
            }

            // Add grep, find, nano and other commands from previous implementation...
            grep(args) {
                if (args.length === 0) {
                    this.addOutput('grep: missing pattern', 'error');
                    return;
                }

                const pattern = args[0];
                const files = [];
                let caseInsensitive = false;
                let showLineNumbers = false;

                for (let i = 1; i < args.length; i++) {
                    if (args[i].startsWith('-')) {
                        if (args[i].includes('i')) caseInsensitive = true;
                        if (args[i].includes('n')) showLineNumbers = true;
                    } else {
                        files.push(args[i]);
                    }
                }

                if (files.length === 0) {
                    this.addOutput('grep: no files specified', 'error');
                    return;
                }

                files.forEach(fileName => {
                    const filePath = this.resolvePath(fileName);
                    const file = this.getDirectory(filePath);
                    
                    if (!file) {
                        this.addOutput(`grep: ${fileName}: No such file or directory`, 'error');
                        return;
                    }
                    
                    if (typeof file === 'object') {
                        this.addOutput(`grep: ${fileName}: Is a directory`, 'error');
                        return;
                    }

                    const lines = file.split('\n');
                    const regex = new RegExp(pattern, caseInsensitive ? 'gi' : 'g');
                    
                    lines.forEach((line, index) => {
                        if (regex.test(line)) {
                            let output = '';
                            if (files.length > 1) output += `${fileName}:`;
                            if (showLineNumbers) output += `${index + 1}:`;
                            output += line;
                            this.addOutput(output, 'success');
                        }
                    });
                });
            }

            find(args) {
                const startPath = args[0] && !args[0].startsWith('-') ? args[0] : '.';
                const resolvedPath = this.resolvePath(startPath);
                const startDir = this.getDirectory(resolvedPath);
                
                if (!startDir || typeof startDir === 'string') {
                    this.addOutput(`find: '${startPath}': No such file or directory`, 'error');
                    return;
                }

                let namePattern = null;
                let typeFilter = null;
                
                for (let i = 0; i < args.length; i++) {
                    if (args[i] === '-name' && args[i + 1]) {
                        namePattern = args[i + 1].replace(/\*/g, '.*');
                        i++;
                    } else if (args[i] === '-type' && args[i + 1]) {
                        typeFilter = args[i + 1];
                        i++;
                    }
                }

                this.findRecursive(startDir, resolvedPath, namePattern, typeFilter);
            }

            findRecursive(dir, currentPath, namePattern, typeFilter) {
                Object.keys(dir).forEach(item => {
                    const itemPath = currentPath === '/' ? `/${item}` : `${currentPath}/${item}`;
                    const itemData = dir[item];
                    
                    if (typeof itemData === 'object') {
                        if (!namePattern || new RegExp(namePattern, 'i').test(item)) {
                            if (!typeFilter || typeFilter === 'd') {
                                this.addOutput(itemPath, 'info');
                            }
                        }
                        this.findRecursive(itemData, itemPath, namePattern, typeFilter);
                    } else {
                        if (!namePattern || new RegExp(namePattern, 'i').test(item)) {
                            if (!typeFilter || typeFilter === 'f') {
                                this.addOutput(itemPath);
                            }
                        }
                    }
                });
            }

            nano(args) {
                const fileName = args[0];
                if (!fileName) {
                    this.addOutput('nano: missing filename', 'error');
                    return;
                }

                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                let content = '';
                let isNewFile = false;

                if (!file) {
                    isNewFile = true;
                } else if (typeof file === 'object') {
                    this.addOutput(`nano: ${fileName}: Is a directory`, 'error');
                    return;
                } else {
                    content = file;
                }

                this.openNanoEditor(fileName, filePath, content, isNewFile);
            }

            openNanoEditor(fileName, filePath, content, isNewFile) {
                const editor = document.createElement('div');
                editor.className = 'nano-editor';
                
                const header = document.createElement('div');
                header.className = 'nano-header';
                header.textContent = `GNU nano 5.4    ${fileName}${isNewFile ? ' [New File]' : ''}`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'nano-content';
                
                const textarea = document.createElement('textarea');
                textarea.className = 'nano-textarea';
                textarea.value = content;
                textarea.placeholder = 'Enter text here...';
                
                const footer = document.createElement('div');
                footer.className = 'nano-footer';
                footer.innerHTML = `
                    <div class="nano-help">
                        <span><span class="nano-shortcut">^X</span> Exit</span>
                        <span><span class="nano-shortcut">^O</span> Write Out</span>
                        <span><span class="nano-shortcut">^W</span> Where Is</span>
                        <span><span class="nano-shortcut">^K</span> Cut Text</span>
                        <span><span class="nano-shortcut">^U</span> Paste Text</span>
                    </div>
                `;
                
                contentDiv.appendChild(textarea);
                editor.appendChild(header);
                editor.appendChild(contentDiv);
                editor.appendChild(footer);
                document.body.appendChild(editor);
                
                textarea.focus();
                
                textarea.addEventListener('keydown', (e) => {
                    if (e.ctrlKey) {
                        switch (e.key.toLowerCase()) {
                            case 'x':
                                e.preventDefault();
                                this.closeNanoEditor(editor, textarea.value, filePath, fileName);
                                break;
                            case 'o':
                                e.preventDefault();
                                this.saveNanoFile(textarea.value, filePath, fileName);
                                break;
                        }
                    }
                });
            }

            closeNanoEditor(editor, content, filePath, fileName) {
                const originalContent = this.getDirectory(filePath) || '';
                
                if (content !== originalContent) {
                    const save = confirm('Save modified buffer?');
                    if (save) {
                        this.saveNanoFile(content, filePath, fileName);
                    }
                }
                
                document.body.removeChild(editor);
                this.input.focus();
            }

            saveNanoFile(content, filePath, fileName) {
                const parentPath = filePath.substring(0, filePath.lastIndexOf('/')) || '/';
                const fileNameOnly = filePath.substring(filePath.lastIndexOf('/') + 1);
                
                const parentDir = this.getDirectory(parentPath);
                if (!parentDir || typeof parentDir === 'string') {
                    alert(`Cannot save: Directory ${parentPath} does not exist`);
                    return;
                }
                
                parentDir[fileNameOnly] = content;
                this.addOutput(`File '${fileName}' saved`, 'success');
            }

            // Add other missing commands...
            vim(args) {
                this.addOutput('vim: command not fully implemented. Use nano instead.', 'warning');
            }

            head(args) {
                const fileName = args[0];
                const lines = parseInt(args[1]) || 10;
                
                if (!fileName) {
                    this.addOutput('head: missing filename', 'error');
                    return;
                }
                
                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`head: ${fileName}: No such file or directory`, 'error');
                    return;
                }
                
                if (typeof file === 'object') {
                    this.addOutput(`head: ${fileName}: Is a directory`, 'error');
                    return;
                }
                
                const fileLines = file.split('\n');
                const output = fileLines.slice(0, lines).join('\n');
                this.addOutput(output);
            }

            tail(args) {
                const fileName = args[0];
                const lines = parseInt(args[1]) || 10;
                
                if (!fileName) {
                    this.addOutput('tail: missing filename', 'error');
                    return;
                }
                
                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`tail: ${fileName}: No such file or directory`, 'error');
                    return;
                }
                
                if (typeof file === 'object') {
                    this.addOutput(`tail: ${fileName}: Is a directory`, 'error');
                    return;
                }
                
                const fileLines = file.split('\n');
                const output = fileLines.slice(-lines).join('\n');
                this.addOutput(output);
            }

            wc(args) {
                if (!args[0]) {
                    this.addOutput('wc: missing filename', 'error');
                    return;
                }
                
                const fileName = args[0];
                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`wc: ${fileName}: No such file or directory`, 'error');
                    return;
                }
                
                if (typeof file === 'object') {
                    this.addOutput(`wc: ${fileName}: Is a directory`, 'error');
                    return;
                }
                
                const lines = file.split('\n').length;
                const words = file.split(/\s+/).filter(word => word.length > 0).length;
                const chars = file.length;
                
                this.addOutput(`${lines} ${words} ${chars} ${fileName}`);
            }

            sort(args) {
                if (!args[0]) {
                    this.addOutput('sort: missing filename', 'error');
                    return;
                }
                
                const fileName = args[0];
                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`sort: ${fileName}: No such file or directory`, 'error');
                    return;
                }
                
                if (typeof file === 'object') {
                    this.addOutput(`sort: ${fileName}: Is a directory`, 'error');
                    return;
                }
                
                const lines = file.split('\n').sort();
                this.addOutput(lines.join('\n'));
            }

            uniq(args) {
                if (!args[0]) {
                    this.addOutput('uniq: missing filename', 'error');
                    return;
                }
                
                const fileName = args[0];
                const filePath = this.resolvePath(fileName);
                const file = this.getDirectory(filePath);
                
                if (!file) {
                    this.addOutput(`uniq: ${fileName}: No such file or directory`, 'error');
                    return;
                }
                
                if (typeof file === 'object') {
                    this.addOutput(`uniq: ${fileName}: Is a directory`, 'error');
                    return;
                }
                
                const lines = file.split('\n');
                const uniqueLines = [];
                let lastLine = '';
                
                lines.forEach(line => {
                    if (line !== lastLine) {
                        uniqueLines.push(line);
                        lastLine = line;
                    }
                });
                
                this.addOutput(uniqueLines.join('\n'));
            }

            which(args) {
                if (!args[0]) {
                    this.addOutput('which: missing command name', 'error');
                    return;
                }
                
                const command = args[0];
                if (this.commands[command]) {
                    this.addOutput(`/usr/bin/${command}`);
                } else {
                    this.addOutput(`which: no ${command} in (/usr/bin:/bin:/usr/sbin:/sbin)`, 'error');
                }
            }

            man(args) {
                if (!args[0]) {
                    this.addOutput('What manual page do you want?', 'error');
                    return;
                }
                
                const command = args[0];
                const manPages = {
                    'ls': 'NAME\n       ls - list directory contents\n\nSYNOPSIS\n       ls [OPTION]... [FILE]...\n\nDESCRIPTION\n       List information about the FILEs.',
                    'grep': 'NAME\n       grep - print lines matching a pattern\n\nSYNOPSIS\n       grep [OPTIONS] PATTERN [FILE...]\n\nOPTIONS\n       -i: ignore case\n       -n: show line numbers',
                    'find': 'NAME\n       find - search for files and directories\n\nSYNOPSIS\n       find [path] [expression]\n\nOPTIONS\n       -name pattern: search by name\n       -type f: files only\n       -type d: directories only',
                    'nano': 'NAME\n       nano - simple text editor\n\nSYNOPSIS\n       nano [filename]\n\nKEYBOARD SHORTCUTS\n       Ctrl+X: exit\n       Ctrl+O: save file',
                    'cp': 'NAME\n       cp - copy files or directories\n\nSYNOPSIS\n       cp source destination\n\nDESCRIPTION\n       Copy SOURCE to DEST.',
                    'mv': 'NAME\n       mv - move/rename files or directories\n\nSYNOPSIS\n       mv source destination\n\nDESCRIPTION\n       Move SOURCE to DEST.',
                    'sudo': 'NAME\n       sudo - execute a command as another user\n\nSYNOPSIS\n       sudo [command]\n\nDESCRIPTION\n       Execute commands as superuser.'
                };
                
                if (manPages[command]) {
                    this.addOutput(manPages[command], 'info');
                } else {
                    this.addOutput(`No manual entry for ${command}`, 'error');
                }
            }

            ps() {
                const processes = `  PID TTY          TIME CMD
    1 ?        00:00:01 systemd
    2 ?        00:00:00 kthreadd
  123 pts/0    00:00:00 bash
  456 pts/0    00:00:00 web-terminal-desktop
  789 pts/0    00:00:00 ps`;
                this.addOutput(processes);
            }

            top() {
                const topOutput = `top - ${new Date().toLocaleTimeString()} up ${Math.floor(performance.now() / 1000 / 60)} min,  1 user,  load average: 0.15, 0.10, 0.05
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.3 us,  1.2 sy,  0.0 ni, 96.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   2048.0 total,   1024.0 free,    512.0 used,    512.0 buff/cache

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0  169364  13940   8796 S   0.0   0.7   0:01.23 systemd
  123 user      20   0   21292   5124   3456 S   0.0   0.3   0:00.12 bash
  456 user      20   0   15432   3892   2134 R   1.2   0.2   0:00.05 web-terminal-desktop`;
                this.addOutput(topOutput);
            }

            df() {
                const dfOutput = `Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/web           10240    5120      5120  50% /
tmpfs               1024       0      1024   0% /dev/shm
/dev/web/home       5120    2048      3072  40% /home
/dev/web/desktop    2048    1024      1024  50% /desktop`;
                this.addOutput(dfOutput);
            }

            free() {
                const totalMem = performance.memory?.totalJSHeapSize || 134217728;
                const usedMem = performance.memory?.usedJSHeapSize || 67108864;
                const freeMem = totalMem - usedMem;
                
                const freeOutput = `              total        used        free      shared  buff/cache   available
Mem:        ${Math.round(totalMem/1024)}      ${Math.round(usedMem/1024)}      ${Math.round(freeMem/1024)}           0           0      ${Math.round(freeMem/1024)}
Swap:            0           0           0`;
                this.addOutput(freeOutput);
            }

            uptime() {
                const uptimeSeconds = Math.floor(performance.now() / 1000);
                const hours = Math.floor(uptimeSeconds / 3600);
                const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                
                this.addOutput(`${new Date().toLocaleTimeString()} up ${hours}:${minutes.toString().padStart(2, '0')}, 1 user, load average: 0.15, 0.10, 0.05`);
            }

            cowsay(args) {
                const message = args.join(' ') || 'Hello from the desktop terminal!';
                const messageLength = message.length;
                const border = '_'.repeat(messageLength + 2);
                
                const cow = `
 ${border}
< ${message} >
 ${'-'.repeat(messageLength + 2)}
        \\   ^__^
         \\  (oo)\\_______
            (__)\\       )\\/\\
                ||----w |
                ||     ||`;
                
                this.addOutput(cow, 'ascii-art');
            }

            fortune() {
                const fortunes = [
                    "The best way to predict the future is to invent it.",
                    "Life is what happens to you while you're busy making other plans.",
                    "The only way to do great work is to love what you do.",
                    "Innovation distinguishes between a leader and a follower.",
                    "Welcome to the Matrix. Red pill or blue pill?",
                    "In the desktop environment, you are the master of your domain.",
                    "sudo makes you powerful, but with great power comes great responsibility.",
                    "The terminal is your gateway to infinite possibilities."
                ];
                
                const randomFortune = fortunes[Math.floor(Math.random() * fortunes.length)];
                this.addOutput(randomFortune, 'success');
            }

            figlet(args) {
                const text = args.join(' ') || 'DESKTOP';
                const figletText = text.toUpperCase().split('').map(char => {
                    switch(char) {
                        case 'A': return ' ‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà';
                        case 'B': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ';
                        case 'C': return ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà     \n‚ñà‚ñà     \n‚ñà‚ñà     \n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà';
                        case 'D': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ';
                        case 'E': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà     \n‚ñà‚ñà‚ñà‚ñà‚ñà  \n‚ñà‚ñà     \n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà';
                        case 'H': return '‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà';
                        case 'K': return '‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà  ‚ñà‚ñà \n‚ñà‚ñà‚ñà‚ñà‚ñà  \n‚ñà‚ñà  ‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà';
                        case 'L': return '‚ñà‚ñà     \n‚ñà‚ñà     \n‚ñà‚ñà     \n‚ñà‚ñà     \n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà';
                        case 'M': return '‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà\n‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà\n‚ñà‚ñà      ‚ñà‚ñà';
                        case 'O': return ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà    ‚ñà‚ñà\n‚ñà‚ñà    ‚ñà‚ñà\n‚ñà‚ñà    ‚ñà‚ñà\n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ';
                        case 'P': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà     \n‚ñà‚ñà     ';
                        case 'R': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà   ‚ñà‚ñà\n‚ñà‚ñà   ‚ñà‚ñà';
                        case 'S': return ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà     \n ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n      ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ';
                        case 'T': return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n   ‚ñà‚ñà   \n   ‚ñà‚ñà   \n   ‚ñà‚ñà   \n   ‚ñà‚ñà   ';
                        case 'W': return '‚ñà‚ñà      ‚ñà‚ñà\n‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà\n‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà\n‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà';
                        case ' ': return '       \n       \n       \n       \n       ';
                        default: return '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà  ‚ñà‚ñà \n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà  ‚ñà‚ñà \n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ';
                    }
                }).join('  ');
                
                this.addOutput(figletText, 'ascii-art');
            }

            tree(args) {
                const path = this.resolvePath(args[0] || '.');
                const dir = this.getDirectory(path);
                
                if (!dir || typeof dir === 'string') {
                    this.addOutput(`tree: ${args[0] || '.'}: No such directory`, 'error');
                    return;
                }
                
                this.addOutput(path);
                this.printTree(dir, '', true);
            }

            printTree(dir, prefix, isLast) {
                const items = Object.keys(dir).sort();
                items.forEach((item, index) => {
                    const isLastItem = index === items.length - 1;
                    const connector = isLastItem ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
                    const itemData = dir[item];
                    
                    if (typeof itemData === 'object') {
                        this.addHTMLOutput(`${prefix}${connector}<span class="directory">${item}</span>`);
                        const newPrefix = prefix + (isLastItem ? '    ' : '‚îÇ   ');
                        this.printTree(itemData, newPrefix, isLastItem);
                    } else {
                        this.addHTMLOutput(`${prefix}${connector}<span class="file">${item}</span>`);
                    }
                });
            }
        }

        // Initialize terminal when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.webTerminal = new WebTerminal();
        });
    </script>
</body>
</html>
